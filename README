This readme will serve as the design document of nesblox.

Part 1: Gameplay
=================

The gameplay of nesblox is going to be pretty simple.
The objective of the game is to move the player character throuhg a maze 
made of of blocks with certain rules (like one way blocks) without crossing its own path.
There will be several obsticle blocks.
The game should have a built in map editor with which maps can be designed. 
Maps will be saved to sram.
All maps will fit on one screen.
There will be at least 32 built in maps and 4-6 slots for player defined maps.
The map editor needs to be able to compress maps. 
The map loader will be able to uncompress them. 
All maps will be stored somewhere in ram as well as in screen ram.
Map updates will take place both in ram and screen ram to keep copies consistent.
The map editor will allow placing any available tile anywhere on the screen.
The main menu will simply consist of a map picker.
The map editor will have a save menu where a map slot will be picked.

Part 2: Other features
=======================
The game should be available for free and as a payed version on steam distributed using an open source 
nes emulator. 
The steam release should have a launcher that allows users to pick sram files downloaded from the steam workshop.
It should also allow uploading the users sram file to the workshop.
This will be the main feature of them game: Shareable maps over the internet.
The sram will not contain anything but map files.
The game should use a mapper with as little features as possible.
Generally a few banks of rom should do to contain the game.
One bank of sram should also be enough depending on how well compression works.

All graphics design can be easily done using Mesens PPU viewer.
Once done simply export the CHR ROM to a dump and it can be included using .incbin.

Part 3: Level Compression:
==========================
Level compression is implemented using a very simple format.
It is simply stores a number of repeates followed by the tile to be repeated.
A repeate sequence is indicated with a value of $FF consequently making $FF an invalid 
tile not to be used. If an FF does not preceede a value it simply means it is a single occurance of a tile.
The end of data is indicated by $FF $00
Example:

$01 $02 $02 $03 $FF $09 $FA $FF $00

This will expand to:
$01 $02 $02 $03 $FA $FA $FA $FA $FA $FA $FA $FA $FA 

This simple example saved 3 bytes in total.


PART 4: Audio format:
=====================
All audio data is placed in in the following format.
duty, note

Where timer_frames is the amount of frames a note plays for and note
is a value is an offset in the periode lookup table.
Duty is the duty setting for this note.
Sweep is a value for the sweep unit that is unused as of now.
If duty is $FF no update will happen.

Noise:
=======
The noise format is slightly different

duty, note, length counter

Part 5: Notes (To be removed):
===============================

TODO init save data (magic number?)
TODO implement low visiblity mode.
    - Move sprites off-screen if out of range
    - reveal map when player moves
    - init routine for initial visiblity
TODO make inital map loading code and reset code the same for gameplay
TODO map loading in low visibility mode does not work correclty when using jump tiles
TODO do not render sprites that are outside of vield of view in low visiblity mode


Blocks:
- Wall blocks (cannot be walked on)
- Space blocks (can be walked on)
- One way blocks in all directions
- Switch blocks that make blocks (im)passible. Switch blocks will be blocked off with sprites
- Start block (TODO handle error when no start is present)
- Teleport blocks/Jump blocks
- Push block, pushable block may also be pushed onto empty tile where it then "falls"
- Red door, opens when Red door key is collected
- Blue door, opens when Blue door key is collected
- Green door, opens when Green door key is collected
- Bombable block

- Mimmic AI that copies player can interact with switches (inverted sprite of player?)
- Skel AI moves randomly
- Bat AI moves left, until wall then right until wall
- Scorpion AI moves up, until wall then down until wall
- Block that changes solid every time player moves
- Staircase tile as "goal" (sets tiles to clear to 0)
- Bomb pickup 
- Armor Pickup, +1 hp pickup

- Add weapon damage pickup
- Add health bar 3 hearts
- Add health pickup
- Add hp to enemies
- Randomly generate dungeons??
- Make rendering so it only renders a few tiles around the player
  when the map first loads. Then on every move load
  a row of tiles (6 or so) in the direction the player went.

- Fix movement, quick tap in direction changes facing direction, long press starts move
  this will allow better combat

TODO:
Each map may have up to 32 sprite based tiles. each of those tiles gets 1 sprite slot assigned.
These tiles are looked for in the same routine as the find_start tile.
Enemy AI needs to check if it collided with player
Death Animation
Play sounds for sword slash, key pickup, sword pickup, door open

Setting:
You are a wizard who must venture through the dungeon to find the necronomicon.
On the way you must prove your wit, and avoid deadly bats, skelletons and other creatures.
